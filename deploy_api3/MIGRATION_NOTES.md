# deploy_api3 - Schema-First Architecture

## Structure

```
deploy_api3/
├── config.py          # Configuration
├── schemas.py         # Entity definitions with @entity decorators
├── main.py            # App factory, imports schemas
└── src/
    ├── __init__.py    # Re-exports from schemas
    └── stores/        # Custom queries only (no BaseStore)
        ├── projects.py
        ├── services.py
        ├── deployments.py
        ├── droplets.py
        ├── containers.py
        └── snapshots.py
```

## How It Works

### 1. schemas.py Defines Entities

```python
from dataclasses import dataclass
from typing import List, Optional
from databases import entity, entity_field

@entity(table="projects")
@dataclass
class Project:
    name: str
    workspace_id: str = entity_field(index=True)
    tags: List[str] = entity_field(default=None)  # JSON auto-serialized
    id: Optional[str] = None
    created_at: Optional[str] = None
    updated_at: Optional[str] = None
    deleted_at: Optional[str] = None
```

The `@entity` decorator auto-adds CRUD methods:
- `Project.get(db, id)` - fetch by ID
- `Project.create(db, data)` - insert with auto id/timestamps
- `Project.update(db, id, data)` - merge and save
- `Project.delete(db, id, permanent=True)` - hard delete
- `Project.soft_delete(db, id)` - set deleted_at
- `Project.find(db, where=, params=, ...)` - query

### 2. Stores Are Just Custom Queries

```python
# stores/projects.py
from ...schemas import Project

# Re-exports for backward compatibility
get = Project.get
create = Project.save
update = Project.update
delete = Project.delete

# Custom queries
async def get_by_name(db, workspace_id: str, name: str):
    results = await Project.find(
        db,
        where="workspace_id = ? AND name = ? AND deleted_at IS NULL",
        params=(workspace_id, name),
        limit=1,
    )
    return results[0] if results else None

async def list_for_workspace(db, workspace_id: str):
    return await Project.find(
        db,
        where="workspace_id = ? AND deleted_at IS NULL",
        params=(workspace_id,),
    )
```

### 3. Usage

```python
from deploy_api3.schemas import Project
from deploy_api3.src.stores import projects

# Direct entity usage (preferred for simple CRUD)
project = await Project.get(db, "123")
project = await Project.create(db, {"name": "test", "workspace_id": "ws1"})

# Store usage (for custom queries or backward compatibility)
project = await projects.get_by_name(db, "ws1", "myproject")
all_projects = await projects.list_for_workspace(db, "ws1")

# Dict-like access on entities
print(project["name"])  # or project.name
print(project.tags)     # List - auto-deserialized from JSON
```

## What Was Removed

| Removed | Replaced By |
|---------|-------------|
| `models.py` | Type hints in `schemas.py` drive JSON deserialization |
| `BaseStore` class | CRUD methods built into `@entity` decorator |
| `_serialize()` | Handled by databases module |
| Manual `from_dict()` | Auto-generated by `@entity` |

## Key Features

### Auto JSON Serialization

Fields with `List` or `Dict` type hints are automatically serialized/deserialized:

```python
@entity(table="deployments")
@dataclass
class Deployment:
    droplet_ids: List[str] = entity_field(default=None)

# Save: droplet_ids=['a','b'] → stored as '["a","b"]'
# Load: '["a","b"]' → automatically becomes ['a','b']
```

### Dict-Like Access

Entities support both attribute and dict access:

```python
project.name           # attribute access
project["name"]        # dict access (backward compat)
project.get("name")    # .get() with default
```

## Migration from Old Structure

| Before | After |
|--------|-------|
| `from .models import Project` | `from .schemas import Project` |
| `await ProjectStore.get(db, id)` | `await Project.get(db, id)` |
| `await ProjectStore.create(db, data)` | `await Project.create(db, data)` |
| `await projects.create(db, data)` | Works unchanged (re-exported) |

## Benefits

- **No BaseStore class** - CRUD built into entities
- **No models.py** - Type hints drive deserialization  
- **No manual serialization** - Handled automatically
- **Simpler stores** - Just custom queries
- **Type safety** - Dataclasses with hints
- **Dict compatibility** - Works with existing code
